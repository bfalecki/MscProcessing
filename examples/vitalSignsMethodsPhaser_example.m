folder = "C:\Users\bfalecki\Documents\challenge\rec\";
% folder = "/home/user/Documents/praca_mgr/measurements/phaser/";

filename = "phaser_rec_04-Dec-2025_18-23-11_vs0.5m.mat";
range_cell = 0.3; % meters

% filename = "phaser_rec_04-Dec-2025_18-39-31_vs1m.mat";
% range_cell = 1; % meters

% filename = "phaser_rec_04-Dec-2025_18-46-23_vs2m.mat";
% range_cell = 2; % meters

rangeCellMeters = [0.25 2.5];

lengthSeconds = 180;
offsetSeconds = 30;
rawData = readRawPhaser(folder+filename,"lengthSeconds",lengthSeconds,"offsetSeconds",offsetSeconds);

%%
% figure(1); rawData.plotIQ()
% figure(2); rawData.plotMatrix()

%% 

fast_time_data_start = 1;
fast_time_data_end = 2045;
FastTimeWindow = "hann";
rangeTimeMap = raw2rtm(rawData,"fast_time_data_start",fast_time_data_start, "fast_time_data_end",fast_time_data_end,"Window",FastTimeWindow);
slowTimeSignal = rtm2sts(rangeTimeMap,rangeCellMeters);
slowTimeSignal.selectSingleCell(range_cell);
phaseUnwrappingMethod = "atan";
slowTimePhase = sts2stp(slowTimeSignal,"method",phaseUnwrappingMethod);


figure(3); slowTimeSignal.plotSignal()
figure(4); slowTimePhase.plotPhase()
figure(5); slowTimePhase.plotPhaseDiff()


%% preprocessing
figure(6); [slowTimePhase, phaseDiscontCompParams] = slowTimeSignal.removePhaseDiscontinuities("Display",1,"ThresholdMultiplier",5);

%% optional save pre-processed signal to file
preprocDir = "data" + filesep;
filepathPreprocessed = makeOutputFilename(filename, "preproc", preprocDir, "extension",".mat");
save(filepathPreprocessed, "slowTimeSignal","slowTimePhase", ...
    "phaseDiscontCompParams","phaseUnwrappingMethod", ...
    "FastTimeWindow","fast_time_data_start", "fast_time_data_end", ...
    "filename", "range_cell", "lengthSeconds", "offsetSeconds")

%% optional read pre-processed signal from file
% filepathPreprocessed = "data\phaser_rec_04-Dec-2025_18-23-11_vs0.5m__preproc.mat";
% filepathPreprocessed = "data\phaser_rec_04-Dec-2025_18-39-31_vs1m__preproc.mat";
filepathPreprocessed = "data\phaser_rec_04-Dec-2025_18-46-23_vs2m__preproc.mat";
load(filepathPreprocessed)

%% Breath rate extraction
% tfa0 = TimeFreqAnalyzer("WindowWidth",10,"FrequencyResolution",1/60/4,"MaximumVisibleFrequency",1,"Synchrosqueezed",1);
% tfa0.transform(slowTimePhase)
% tfa0.detectRidge( ...
%     "NuberOfRidges",1, ...
%     "SelectMethod","first", ...
%     "JumpPenalty",2, ...
%     "PossibleHighFrequency",0.8,  "PossibleLowFrequency",0.05)
% figure(7); tfa0.plotResults("QuantileVal",0.8,"AllRidges",1,"PlotPeaks",0)

%% PhaseStftHearbeatExtractor
pshe = PhaseStftHearbeatExtractor("heartOscillationFreqRange", [5 15], ...
    "frequencyResolution",0.5, ...
    "phaseCutoffFreqLow",5, ...
    "windowWidth", 0.25, ...
    "resultCutoffFreqLow",0.5);
pshe.process(slowTimePhase);
figure(111); pshe.plotHeartbeatSignal;
figure(121); pshe.plotStft;

%% BandPassHeartbeatExtractor
bphe = BandPassHeartbeatExtractor("PassBand",[0.8 1.8]);
bphe.process(slowTimePhase)
figure(991); bphe.plotResult()

%% Combined BandPassHeartbeatExtractor and PhaseStftHearbeatExtractor

rc = ResultsCombiner();
% rc.combine(bphe, pshe,"timeDelay2",0.15, "weights",[-1, 1]);
rc.combine(bphe, pshe,"estimateDelay",1,"estimateSign",0, "weights",[1, 1],"windowWidth",10,"windowStep",5);

figure(191); rc.plotEstimatedDelay()
figure(192); rc.plotResult()

%% prediction in breaks
rc.predictGaps("ErosePart",0.15,"PartConsidered",1);
figure(194); rc.plotResult("PlotCombined",1,"PlotSig1",0,"PlotSig2Adjusted",0,"PlotSIg2Original",0,"PlotSig2Sign",0, "PlotPredicted",1)
rc.setTfAnalysisOutput("predicted"); % "default" / "predicted" 


% % envelope normalization
% normWindow = 2; % seconds
% windowWidth = round(normWindow*rc.getSamplingFrequency);
% combinedSignalEnvelopeNorm = normalizeEnvelope(rc.combinedSignal,windowWidth);
% rc.combinedSignal = combinedSignalEnvelopeNorm;

%% Inter-beat interval estimation
% [start_samples,end_samples] =  rc.getSegmentsStartsEnds;
% ibi = estimateIbi(combinedSignalEnvelopeNorm, rc.getSamplingFrequency, ...
%     "StartSamples",start_samples, ...
%     "EndSamples",end_samples, ...
%     "EroseSize",0);

%% Time-Frequency Analysis
tfAnalyzables = {pshe,bphe, rc};
tfaVect = {};
fig_nr = [1211 992 193];

for k = 1:length(tfAnalyzables)
    tfaVect{k} = TimeFreqAnalyzer( ...
        "WindowWidth",10, ...
        "FrequencyResolution",0.25/60, ...
        "MaximumVisibleFrequency",150/60, ...
        "Synchrosqueezed",0);
    tfaVect{k}.transform(tfAnalyzables{k})
    % find time-frequency ridge with memory
    tfaVect{k}.detectRidge( ...
    "NuberOfRidges",3, ...
    "PossibleLowFrequency",40/60,...
    "PossibleHighFrequency",150/60,...
    "JumpPenalty",0.1, ...
    "SelectMethod","first", ... "lowest" / "first" / "nearest" / "middle"
    "DesiredNearestFrequency", 80/60 ...
    );
    % find time-frequency ridge without memory
    frequencyDistanceToHarmonics = 1/mean(diff(slowTimeSignal.signalInfo.frameStartTimes)); % frame-length dependent
    tfaVect{k}.detectPeaks( ...
        "Method", "highest", ...  "highest" / "lower" / "middle" / "distanceBased"
        "ExactDistance",frequencyDistanceToHarmonics, ...
        "DistanceTolerance",0.1 * frequencyDistanceToHarmonics ...
        );
    figure(fig_nr(k));
    tfaVect{k}.plotResults( ...
        "QuantileVal",0.5,"AllRidges",1, "PlotRidges",1,"PlotPeaks",1,"PlotPeaksHarmonics",1)
end

%% Comparison with Reference: RMSE with Memory ------- 
referencePath = "C:\Users\bfalecki\Documents\challenge\reference\kalenji\2025-12-04.fit";
hre = HeartRateReference(referencePath,"ManualTimeShift",1-5/3600);
cellfun(@(x) x.setHeartRateOutput("ridge"),tfaVect)
errors_memory = hre.calucateError(tfaVect);
figure(10101);hre.plot("otherResults",tfaVect, "showAdjusted",1)
disp("RMSE with memory in BPM: " + join(string(errors_memory)))

%% Comparison with Reference: RMSE without Memory - - -  -
cellfun(@(x) x.setHeartRateOutput("peaks"),tfaVect)
errors_nomemory =  hre.calucateError(tfaVect);
figure(10102);hre.plot("otherResults",tfaVect)
disp("RMSE without memory in BPM: " + join(string(errors_nomemory)))

%% Save Parameters and Estimation Errors
outDir = "results" + filesep + "phaser-process-exp" + filesep;

% suffix
token = regexp(filename, '_vs([0-9.]+m)', 'tokens');
distLog = token{1}{1};
predictionApplied = strcmp(rc.tfAnalysisOutput, "predicted");
synchrosqueezingApplied = tfaVect{3}.Synchrosqueezed == 1;
ridgeMethod = tfaVect{3}.detectRidgeSelectMethod;
peaksMethod = tfaVect{3}.detectPeaksMethod;
suffix = sprintf("dist%s_synchr%d_pred%d_ridge-%s_peaks-%s", ...
    distLog,synchrosqueezingApplied,predictionApplied,ridgeMethod,peaksMethod);

% prefix
baseName = "rec_04-Dec-2025";
custom_suffix = "_wow2";

suffix = suffix + custom_suffix;
outPathMat = makeOutputFilename(baseName, suffix, outDir, "extension",".mat");
outPathJson = makeOutputFilename(baseName, suffix, outDir,"extension",".json");

% generated by ChatGPT
experiment = struct();

experiment.errors = struct( ...
    'methods', {{'pshe','bphe','rc'}}, ...
    'memory', errors_memory, ...
    'noMemory', errors_nomemory ...
);

experiment.tfa = cellfun(@(tfa) struct( ...
    'detectPeaksMethod', tfa.detectPeaksMethod, ...
    'detectRidgeSelectMethod', tfa.detectRidgeSelectMethod, ...
    'Synchrosqueezed', tfa.Synchrosqueezed, ...
    'WindowWidth', tfa.WindowWidth, ...
    'FrequencyResolution', tfa.FrequencyResolution, ...
    'MaximumVisibleFrequency', tfa.MaximumVisibleFrequency, ...
    'detectRidgePossibleLowFrequency', tfa.detectRidgePossibleLowFrequency, ...
    'detectRidgePossibleHighFrequency', tfa.detectRidgePossibleHighFrequency, ...
    'detectRidgeJumpPenalty', tfa.detectRidgeJumpPenalty, ...
    'detectRidgeNuberOfRidges', tfa.detectRidgeNuberOfRidges, ...
    'detectRidgeDesiredNearestFrequency', tfa.detectRidgeDesiredNearestFrequency, ...
    'detectPeaksExactDistance', tfa.detectPeaksExactDistance, ...
    'detectPeaksDistanceTolerance', tfa.detectPeaksDistanceTolerance ...
), tfaVect, 'UniformOutput', false);

experiment.loading = struct( ...
    'lengthSeconds', lengthSeconds, ...
    'offsetSeconds', offsetSeconds, ...
    'filename', filename ...
);

experiment.preprocessing = struct( ...
    'range_cell', range_cell, ...
    'fast_time_data_start', fast_time_data_start, ...
    'fast_time_data_end', fast_time_data_end, ...
    'FastTimeWindow', FastTimeWindow, ...
    'phaseUnwrappingMethod', phaseUnwrappingMethod, ...
    'phaseDiscontCompParams', phaseDiscontCompParams ...
);

experiment.pshe = struct( ...
    'desiredTimeRes', pshe.desiredTimeRes, ...
    'windowWidth', pshe.windowWidth, ...
    'frequencyResolution', pshe.frequencyResolution, ...
    'maximumVisibleFrequency', pshe.maximumVisibleFrequency, ...
    'heartOscillationFreqRange', pshe.heartOscillationFreqRange, ...
    'phaseCutoffFreqLow', pshe.phaseCutoffFreqLow, ...
    'resultCutoffFreqLow', pshe.resultCutoffFreqLow ...
);

experiment.bphe = struct( ...
    'PassBand', bphe.PassBand, ...
    'UpsamplingFactor', bphe.UpsamplingFactor ...
);

experiment.rc.input = struct( ...
    'weight1', rc.weight1, ...
    'weight2', rc.weight2, ...
    'timeDelay2', rc.timeDelay2, ...
    'estimateDelay', rc.estimateDelay ...
);

experiment.rc.prediction = struct( ...
    'estimateSign', rc.estimateSign, ...
    'tfAnalysisOutput', rc.tfAnalysisOutput, ...
    'PartConsidered', rc.PartConsidered, ...
    'ErosePart', rc.ErosePart ...
);

experiment.rc.adjustment = struct( ...
    'windowWidth', rc.windowWidth, ...
    'windowStep', rc.windowStep, ...
    'maxAllowableShift', rc.maxAllowableShift ...
);



experiment.hre = struct( ...
    'path', hre.path, ...
    'ManualTimeShift',string(hre.ManualTimeShift, "hh:mm:ss") ...
);


table(experiment.errors.memory', experiment.errors.noMemory', ...
      'RowNames', experiment.errors.methods)

fprintf("Saving results to:\n  %s\n", outPathJson);
% save(outPathMat, 'experiment');

jsonText = jsonencode(experiment, 'PrettyPrint', true);
fid = fopen(outPathJson,'w');
fwrite(fid, jsonText);
fclose(fid);
